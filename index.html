<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Pasajero - Moviit (Firestore Stops + ETA ML)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { margin:0; font-family: sans-serif; text-align:center; }
    #topbar { padding:.5rem; display:flex; gap:.5rem; justify-content:center; flex-wrap:wrap; }
    select { padding:.5rem; font-size:1rem; }
    #map { height: 70vh; width: 100%; }
    #etaPanel { height: 18vh; overflow:auto; padding:.5rem 1rem; background:#f7f7f8; border-top:1px solid #e6e6e6; text-align:left }
  </style>
</head>
<body>

  <h2>Ubicaci√≥n del Transporte</h2>
  <div id="topbar">
    <label for="ruta">Ruta:</label>
    <select id="ruta">
      <option value="">-- Elige una ruta --</option>
      <option value="C47-V1">C47-V1 (Dos templos)</option>
      <option value="C47-V1V">C47-V1 (El vergel)</option>
    </select>

    <label for="parada">Parada:</label>
    <select id="parada" disabled>
      <option value="">-- Selecciona una parada --</option>
    </select>
  </div>

  <div id="map"></div>
  <div id="etaPanel"><em>Selecciona una ruta (y una parada) para ver el ETA.</em></div>

  <script type="module">
    // ================= Firebase =================
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getDatabase, ref, onValue, off, get, set } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";
    import { getFirestore, collection, getDocs, query, orderBy } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyCcVJ7HJM3gS10BcCNdxGmRx5ypzTizNYg",
      authDomain: "moviit-928f2.firebaseapp.com",
      databaseURL: "https://moviit-928f2-default-rtdb.firebaseio.com",
      projectId: "moviit-928f2",
      storageBucket: "moviit-928f2.appspot.com",
      messagingSenderId: "753483147976",
      appId: "1:753483147976:web:1057942a7b78444ebf13fd"
    };
    const app = initializeApp(firebaseConfig);
    const db  = getDatabase(app);       // RTDB para buses + ML
    const fs  = getFirestore(app);      // Firestore para paradas

    // ================ Google Maps ================
    let map, directionsService, directionsRenderer;
    const markers = {};   // { id: google.maps.Marker }  (incluye "usuario" y "stop*")
    let currentRef = null; // listener RTDB
    let currentRouteName = null;

    // Enfoque
    let focusMode = 'user';     // 'user' | 'stop'
    let lastUserPos = null;
    let userCenteredOnce = false;

    // Estado de paradas
    let currentStops = [];       // arreglo de paradas cargadas desde Firestore
    const stopMarkers = [];      // instancias de marcadores de parada
    let selectedStopIndex = null;

    // √çconos
    function getBusIcon() {
      return {
        url: "https://i.imgur.com/QByNhob.png",
        scaledSize: new google.maps.Size(50, 50),
        anchor: new google.maps.Point(25, 45)
      };
    }
    function stopIcon(off=true) {
      return {
        path: google.maps.SymbolPath.CIRCLE,
        scale: 14,
        fillColor: off ? "#811888" : "#FF00FF",
        fillOpacity: off ? 0.35 : 0.95,
        strokeWeight: 2,
        strokeColor: off ? "#666666" : "#A000A0"
      };
    }

    // ---------------- Firestore: cargar paradas ----------------
    async function loadStopsFromFS(rutaId) {
      const q = query(collection(fs, `rutas/${rutaId}/stops`), orderBy("orden", "asc"));
      const snap = await getDocs(q);
      const all = snap.docs.map(d => ({ id: d.id, ...d.data() }));
      // Filtra solo activas y con coords v√°lidas
      return all.filter(s => s.activa !== false && typeof s.lat === 'number' && typeof s.lng === 'number');
    }

    // ---------------- Directions: datos de ruta ----------------
    function obtenerDatosRuta(r) {
      if (r === "C47-V1") {
        return {
          origen:   { lat: 20.583703, lng: -103.334809 },
          destino:  { lat: 20.669765, lng: -103.347323 },
          waypoints: [
            { location: { lat: 20.583637, lng: -103.338024 }, stopover: true },
            { location: { lat: 20.585668, lng: -103.338694 }, stopover: true },
            { location: { lat: 20.587471, lng: -103.340403 }, stopover: true },
            { location: { lat: 20.588580, lng: -103.340928 }, stopover: true },
            { location: { lat: 20.589991, lng: -103.341442 }, stopover: true },
            { location: { lat: 20.593990, lng: -103.340431 }, stopover: true },
            { location: { lat: 20.596156, lng: -103.339498 }, stopover: true },
            { location: { lat: 20.594575, lng: -103.335648 }, stopover: true },
            { location: { lat: 20.595602, lng: -103.333938 }, stopover: true },
            { location: { lat: 20.607082, lng: -103.338062 }, stopover: true },
            { location: { lat: 20.607823, lng: -103.337233 }, stopover: true },
            { location: { lat: 20.609352, lng: -103.336731 }, stopover: true },
            { location: { lat: 20.611056, lng: -103.331965 }, stopover: true },
            { location: { lat: 20.614191, lng: -103.331992 }, stopover: true },
            { location: { lat: 20.615079, lng: -103.332352 }, stopover: true },
            { location: { lat: 20.617560, lng: -103.331096 }, stopover: true },
            { location: { lat: 20.620712, lng: -103.330305 }, stopover: true },
            { location: { lat: 20.621112, lng: -103.329584 }, stopover: true },
            { location: { lat: 20.621499, lng: -103.329991 }, stopover: true },
            { location: { lat: 20.622743, lng: -103.332646 }, stopover: true },
            { location: { lat: 20.623472, lng: -103.332065 }, stopover: true },
            { location: { lat: 20.626003, lng: -103.330553 }, stopover: true },
            { location: { lat: 20.627422, lng: -103.321192 }, stopover: true },
          ]
        };
      }
      else if (r === "C47-V1V") {
        return {
          origen:   { lat: 20.583703, lng: -103.334809 },
          destino:  { lat: 20.669754, lng: -103.338024 },
          waypoints: [
            { location: { lat: 20.583637, lng: -103.338024 }, stopover: true },
            { location: { lat: 20.585668, lng: -103.338694 }, stopover: true },
            { location: { lat: 20.587471, lng: -103.340403 }, stopover: true },
            { location: { lat: 20.588580, lng: -103.340928 }, stopover: true },
            { location: { lat: 20.589991, lng: -103.341442 }, stopover: true },
            { location: { lat: 20.593990, lng: -103.340431 }, stopover: true },
            { location: { lat: 20.596156, lng: -103.339498 }, stopover: true },
            { location: { lat: 20.594575, lng: -103.335648 }, stopover: true },
            { location: { lat: 20.595602, lng: -103.333938 }, stopover: true },
            { location: { lat: 20.607082, lng: -103.338062 }, stopover: true },
            { location: { lat: 20.607823, lng: -103.337233 }, stopover: true },
            { location: { lat: 20.609352, lng: -103.336731 }, stopover: true },
            { location: { lat: 20.611056, lng: -103.331965 }, stopover: true },
            { location: { lat: 20.614191, lng: -103.331992 }, stopover: true },
            { location: { lat: 20.615079, lng: -103.332352 }, stopover: true },
            { location: { lat: 20.617560, lng: -103.331096 }, stopover: true },
            { location: { lat: 20.620712, lng: -103.330305 }, stopover: true },
            { location: { lat: 20.621112, lng: -103.329584 }, stopover: true },
            { location: { lat: 20.621499, lng: -103.329991 }, stopover: true },
            { location: { lat: 20.622743, lng: -103.332646 }, stopover: true },
            { location: { lat: 20.623472, lng: -103.332065 }, stopover: true },
            { location: { lat: 20.626003, lng: -103.330553 }, stopover: true },
            { location: { lat: 20.627422, lng: -103.321192 }, stopover: true },
            { location: { lat: 20.640556, lng: -103.329607 }, stopover: true },
            { location: { lat: 20.652309, lng: -103.337296 }, stopover: true }
          ]
        };
      }
      return null;
    }

    // ================= ML + ETA helpers =================
    let routePath = [];               // Array<LatLng> del trazo de la ruta activa (overview_path)
    let routeCumDist = [];            // Distancia acumulada por v√©rtice (m)
    let stopRouteIndex = {};          // { stopIdx: {vIndex, cumDist} }
    const ML_ALPHA = 0.25;            // suavizado EMA (para RTDB /ml)
    const DEFAULT_SPEED_KMH = 22;     // fallback si no hay datos
    const STALE_MS = 90000;           // descarta muestras > 90s para ETA

    const dist = (a,b) => google.maps.geometry.spherical.computeDistanceBetween(a,b);

    function buildRouteCumDist(path) {
      routeCumDist = [0];
      for (let i=1;i<path.length;i++) routeCumDist[i] = routeCumDist[i-1] + dist(path[i-1], path[i]);
    }

    function snapToRoute(latLng) {
      if (!routePath || routePath.length < 2) return null;
      let best = { seg:-1, proj:null, projDist:Infinity, projCum:0 };
      for (let i=0;i<routePath.length-1;i++){
        const A = routePath[i], B = routePath[i+1];
        const samples = 6; // subdividir para aproximar la proyecci√≥n
        for (let t=0;t<=samples;t++){
          const frac = t/samples;
          const P = google.maps.geometry.spherical.interpolate(A, B, frac);
          const d = dist(P, latLng);
          if (d < best.projDist){
            best = { seg: i, proj: P, projDist: d, projCum: routeCumDist[i] + dist(A, P) };
          }
        }
      }
      return best;
    }

    function remainingDistanceAlongRoute(busCum, stopCum) {
      if (routePath.length < 2) return Infinity;
      return stopCum >= busCum ? (stopCum - busCum) : Infinity;
    }

    function hourBucket(ms) { return String(new Date(ms).getHours()); }

    async function getSegmentSpeedKmh(dbRT, ruta, segIndex, hourStr) {
      const p = `ml/speeds/${ruta}/${segIndex}/${hourStr}`;
      try {
        const snap = await get(ref(dbRT, p));
        if (snap.exists()) { const v = snap.val(); if (typeof v.speed_kmh === 'number') return v.speed_kmh; if (typeof v.speedKmh === 'number') return v.speedKmh; }
      } catch {}
      return DEFAULT_SPEED_KMH;
    }

    async function updateSegmentSpeedEMA(dbRT, ruta, segIndex, hourStr, observedSpeedKmh) {
      const p = `ml/speeds/${ruta}/${segIndex}/${hourStr}`;
      try {
        const r = ref(dbRT, p);
        const snap = await get(r);
        let newSpeed = observedSpeedKmh, count = 1;
        if (snap.exists()) {
          const v = snap.val();
          const prev = (typeof v.speed_kmh === 'number') ? v.speed_kmh : ((typeof v.speedKmh === 'number') ? v.speedKmh : DEFAULT_SPEED_KMH);
          const prevN = (typeof v.count === 'number') ? v.count : 0;
          newSpeed = ML_ALPHA*observedSpeedKmh + (1-ML_ALPHA)*prev;
          count = prevN + 1;
        }
        // Guarda con clave snake_case para ser consistente con tus datos actuales
        await set(r, { speed_kmh: newSpeed, count });
      } catch {}
    }

    const prevBusState = {}; // { id: { lastCum:number, lastTs:number, lastSeg:number } }

    function learnFromBusSample(ruta, id, lat, lng, ts){
      if (!routePath.length || !ts) return;
      const ll = new google.maps.LatLng(lat, lng);
      const snapped = snapToRoute(ll);
      if (!snapped) return;
      const hourStr = hourBucket(ts);
      const curCum = snapped.projCum;
      const prev = prevBusState[id];
      if (prev && ts > prev.lastTs && snapped.seg === prev.lastSeg) {
        const dMeters = Math.max(0, curCum - prev.lastCum);
        const dtSec  = (ts - prev.lastTs) / 1000;
        if (dtSec > 2 && dMeters > 1) {
          const vKmh = (dMeters/1000) / (dtSec/3600);
          const vClamped = Math.min(60, Math.max(3, vKmh));
          updateSegmentSpeedEMA(db, ruta, snapped.seg, hourStr, vClamped);
        }
      }
      prevBusState[id] = { lastCum: curCum, lastTs: ts, lastSeg: snapped.seg };
    }

    async function computeETAForSelectedStop(ruta, busesData){
      const etaDiv = document.getElementById("etaPanel");
      if (selectedStopIndex == null) { etaDiv.innerHTML = "<em>Selecciona una parada para ver el ETA.</em>"; return; }
      if (!routePath.length || !routeCumDist.length) { etaDiv.innerHTML = "<em>Trazo de ruta a√∫n no disponible.</em>"; return; }
      const stopInfo = stopRouteIndex[selectedStopIndex];
      if (!stopInfo) { etaDiv.innerHTML = "<em>Preparando datos de la parada‚Ä¶</em>"; return; }

      const stopCum = stopInfo.cumDist;
      const now = Date.now();
      const hourStr = hourBucket(now);
      let best = { id:null, etaMin: Infinity };

      const entries = Object.entries(busesData || {});
      for (const [id, v] of entries) {
        if (!v || typeof v.lat !== 'number' || typeof v.lng !== 'number') continue;
        const ts = v.timestamp || v.time || now;
        if (now - ts > STALE_MS) continue; // ignora buses viejos

        const snap = snapToRoute(new google.maps.LatLng(v.lat, v.lng));
        if (!snap) continue;
        const remM = remainingDistanceAlongRoute(snap.projCum, stopCum);
        if (!isFinite(remM) || remM <= 0) continue;

        let vKmh = (typeof v.speed_kmh === 'number' && v.speed_kmh > 2) ? v.speed_kmh : ((typeof v.speedKmh === 'number' && v.speedKmh > 2) ? v.speedKmh : undefined);
        if (!vKmh) vKmh = await getSegmentSpeedKmh(db, ruta, snap.seg, hourStr);
        vKmh = Math.max(3, Math.min(60, vKmh));

        const etaMin = Math.round((remM/1000) / vKmh * 60);
        if (etaMin < best.etaMin) best = { id, etaMin };
      }

      if (!isFinite(best.etaMin)) {
        etaDiv.innerHTML = "No hay camiones pr√≥ximos a esta parada.";
      } else {
        const stopLabel = currentStops[selectedStopIndex]?.label || ('Parada '+(selectedStopIndex+1));
        etaDiv.innerHTML = `üïí Tiempo estimado de llegada  <b>${stopLabel}</b>: <b>${best.etaMin} min</b> (Bus ${best.id}).`;
      }
    }

    // --------------- Dibujar ruta y extraer trazo ---------------
    function drawRoute(ruta) {
      if (directionsRenderer) { directionsRenderer.setMap(null); directionsRenderer = null; }
      if (!ruta) { routePath = []; routeCumDist = []; stopRouteIndex = {}; return; }
      const datos = obtenerDatosRuta(ruta);
      if (!datos) { routePath = []; routeCumDist = []; stopRouteIndex = {}; return; }

      directionsRenderer = new google.maps.DirectionsRenderer({
        map,
        suppressMarkers: true,
        preserveViewport: true,
        polylineOptions: { strokeColor: "#05500F", strokeWeight: 5 }
      });

      directionsService.route({
        origin: datos.origen,
        destination: datos.destino,
        waypoints: datos.waypoints,
        travelMode: google.maps.TravelMode.DRIVING
      }, (result, status) => {
        if (status === google.maps.DirectionsStatus.OK) {
          directionsRenderer.setDirections(result);
          const overview = result.routes[0].overview_path; // Array<LatLng>
          routePath = overview;
          buildRouteCumDist(routePath);
          stopRouteIndex = {}; // reset cache de paradas
        } else {
          console.warn("No se pudo trazar la ruta:", status);
        }
      });
    }

    // ---------------- Buses (RTDB) ----------------
    function updateBusMarker(id, lat, lng) {
      const pos = { lat, lng };
      if (!markers[id]) {
        markers[id] = new google.maps.Marker({
          position: pos,
          map,
          title: `Bus ${id}`,
          icon: getBusIcon(),
          label: { text: String(id), fontSize: "11px" }
        });
      } else {
        markers[id].setPosition(pos);
      }
    }
    function clearBusMarkers() {
      Object.keys(markers).forEach(k => {
        if (k !== "usuario" && !k.startsWith("stop")) { markers[k].setMap(null); delete markers[k]; }
      });
    }
    function listenRouteBuses(ruta) {
      if (currentRef) { off(currentRef); currentRef = null; }
      clearBusMarkers();
      if (!ruta) return;

      currentRef = ref(db, "conductores/" + ruta);
      onValue(currentRef, async snap => {
        const data = snap.val();
        const vivos = new Set();

        if (!data) { clearBusMarkers(); document.getElementById('etaPanel').innerHTML = '<em>Sin datos de conductores.</em>'; return; }

        if (typeof data.lat === "number" && typeof data.lng === "number") {
          const id = ruta;
          updateBusMarker(id, data.lat, data.lng);
          vivos.add(id);
          learnFromBusSample(ruta, id, data.lat, data.lng, data.timestamp || Date.now());
        } else {
          for (const [id, pos] of Object.entries(data)) {
            if (pos && typeof pos.lat === "number" && typeof pos.lng === "number") {
              updateBusMarker(id, pos.lat, pos.lng);
              vivos.add(id);
              learnFromBusSample(ruta, id, pos.lat, pos.lng, pos.timestamp || Date.now());
            }
          }
        }

        // limpiar buses que ya no existen
        Object.keys(markers).forEach(k => {
          if (k !== "usuario" && !k.startsWith("stop") && !vivos.has(k)) { markers[k].setMap(null); delete markers[k]; }
        });

        await computeETAForSelectedStop(ruta, data);
      });
    }

    // ---------------- Paradas (UI) ----------------
    function clearStopMarkers() {
      stopMarkers.forEach(m => { m.setMap(null); });
      stopMarkers.length = 0;
      Object.keys(markers).forEach(k => { if (k.startsWith("stop")) { markers[k].setMap(null); delete markers[k]; } });
      selectedStopIndex = null;
    }

    function populateParadaSelect(stops) {
      const selParada = document.getElementById("parada");
      selParada.innerHTML = '<option value="">-- Selecciona una parada --</option>';
      stops.forEach((s, i) => {
        const opt = document.createElement("option");
        opt.value = String(i);
        const name = s.label || `P${i+1}`;
        opt.textContent = `${name} (${Number(s.lat).toFixed(6)}, ${Number(s.lng).toFixed(6)})`;
        selParada.appendChild(opt);
      });
      selParada.disabled = stops.length === 0;
    }

    function createStopMarkers(stops) {
      clearStopMarkers();
      currentStops = stops;
      stops.forEach((s, i) => {
        const m = new google.maps.Marker({
          position: { lat: s.lat, lng: s.lng },
          map,
          icon: stopIcon(true),
          title: `Parada ${i+1}`,
          label: { text: s.label ?? `P${i+1}`, fontSize: "11px" }
        });
        m.addListener("click", () => selectStop(i, true));
        stopMarkers[i] = m;
        markers[`stop${i}`] = m;
      });
    }

    function selectStop(index, pan=false) {
      selectedStopIndex = index;
      focusMode = 'stop';
      stopMarkers.forEach((m, i) => m.setIcon(stopIcon(i !== index)));
      const selParada = document.getElementById("parada");
      if (String(selParada.value) !== String(index)) selParada.value = String(index);

      // Snap de parada al trazo y cachea
      if (currentStops[index] && routePath.length > 1) {
        const sLL = new google.maps.LatLng(currentStops[index].lat, currentStops[index].lng);
        const s = snapToRoute(sLL);
        if (s) stopRouteIndex[index] = { vIndex: s.seg, cumDist: s.projCum };
      }

      if (pan && currentStops[index]) { map.setCenter({lat: currentStops[index].lat, lng: currentStops[index].lng}); map.setZoom(17); }

      // Recalcular ETA inmediato (si ya hay datos)
      if (currentRef) { get(currentRef).then(s => computeETAForSelectedStop(currentRouteName, s.val() || {})); }
    }

    // ---------------- initMap (Opci√≥n A: global) ----------------
    globalThis.initMap = function () {
      map = new google.maps.Map(document.getElementById("map"), { center: { lat: 20.676121, lng: -103.348407 }, zoom: 14 });
      directionsService = new google.maps.DirectionsService();

      // Geolocalizaci√≥n del usuario
      if (navigator.geolocation) {
        navigator.geolocation.watchPosition(
          (pos) => {
            const userPos = { lat: pos.coords.latitude, lng: pos.coords.longitude };
            lastUserPos = userPos;
            if (!markers["usuario"]) {
              markers["usuario"] = new google.maps.Marker({ position: userPos, map, title: "T√∫ est√°s aqu√≠", icon: { path: google.maps.SymbolPath.CIRCLE, scale: 10, fillColor: "#00FF00", fillOpacity: 1, strokeWeight: 2, strokeColor: "#00FF00" } });
            } else { markers["usuario"].setPosition(userPos); }
            if (focusMode === 'user' && !userCenteredOnce) { map.setCenter(userPos); map.setZoom(14); userCenteredOnce = true; }
          },
          (err) => console.warn("No se pudo obtener la ubicaci√≥n:", err),
          { enableHighAccuracy: true }
        );
      }

      // Cambio de ruta
      document.getElementById("ruta").addEventListener("change", async (e) => {
        const ruta = e.target.value;
        currentRouteName = ruta || null;

        if (ruta === "C47-V1") {
          const stops = await loadStopsFromFS("C47-V1"); // Firestore
          populateParadaSelect(stops);
          createStopMarkers(stops);
          document.getElementById("parada").disabled = false;
        }
        else if (ruta === "C47-V1V") {
          const stops = await loadStopsFromFS("C47-V1V"); // Firestore
          populateParadaSelect(stops);
          createStopMarkers(stops);
          document.getElementById("parada").disabled = false;
        }else {
          populateParadaSelect([]);
          clearStopMarkers();
          document.getElementById("parada").disabled = true;
          focusMode = 'user';
          document.getElementById('etaPanel').innerHTML = '<em>Selecciona una parada para ver el ETA.</em>';
          if (lastUserPos) { map.setCenter(lastUserPos); map.setZoom(14); }
        }

        drawRoute(ruta);
        listenRouteBuses(ruta);
      });

      // Cambio de parada
      document.getElementById("parada").addEventListener("change", (e) => {
        const idx = e.target.value === "" ? null : Number(e.target.value);
        if (idx === null) {
          selectedStopIndex = null;
          focusMode = 'user';
          stopMarkers.forEach(m => m.setIcon(stopIcon(true)));
          document.getElementById('etaPanel').innerHTML = '<em>Selecciona una parada para ver el ETA.</em>';
          if (lastUserPos) { map.setCenter(lastUserPos); map.setZoom(14); }
        } else {
          selectStop(idx, true);
        }
      });
    };
  </script>

  <!-- Maps con Geometry (para distancias/proyecciones). NOTA: solo 'defer' para evitar carreras -->
  <script defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCk-MUT9woU3ll3aicvaROD4n-xg09_gJk&libraries=geometry&callback=initMap"></script>
</body>
</html>
